# frozen_string_literal: true

require_relative "base"
require "drb/drb"
require "tempfile"
require "rake"

module CIRunner
  module Runners
    # Runner responsible to detect parse and process a CI output log generated by Minitest.
    #
    # Because minitest doesn't have a CLI built-in, there is a lot of complications to re-run
    # a selection of tests, especially when we need to run the tests in a subprocess.
    #
    # In a nutshell, this Runner will try its best to get the file path of each failures.
    # Without a custom repoter, Minitest will fail pointing to the right file a lot of the time.
    # Therefore CI Runner tries a mix of possibilities (by looking at the stack trace, inferring the class name).
    #
    # Once the logs have been parsed, we tell Ruby to load only the test files that failed. By default, loading
    # those files would make Minitest run all tests included in those files, where we want to run only tests
    # that failed on CI.
    #
    # Minitest doesn't have a way to filter by test name (the -n) isn't powerful enough as two test suites can
    # contain the same name.
    # CI Runner launches a DRB server over a UNIX socket which allows allows the subprocess running minitest
    # to know whether a test should ran. This is accomplished in combination with a Minitest plugin.
    #
    # A vanilla rake task plugs the whole thing in order to not reinvent the wheel.
    class MinitestRunner < Base
      SEED_REGEX = Regexp.union(
        /Run options:.*?--seed\s+(\d+)/, # Default Minitest Statistics Repoter
        /Running tests with run options.*--seed\s+(\d+)/, # MinitestReporters BaseReporter
        /Started with run options.*--seed\s+(\d+)/, # MinitestReporters ProgressReporter
      )
      BUFFER_STARTS = /(Failure|Error):\s*\Z/

      # @param ci_log [String] The CI log output
      #
      # @return [Boolean] Whether this runner detects (and therefore can handle) Minitest from the log output.
      def self.match?(ci_log)
        default_reporter = %r{(Finished in) \d+\.\d{6}s, \d+\.\d{4} runs/s, \d+\.\d{4} assertions/s\.}

        Regexp.union(default_reporter, SEED_REGEX, "minitest").match?(ci_log)
      end

      # @return [String] See Runners::Base#report
      def name
        "Minitest"
      end

      # Start a subprocess to rerun the detected failing tests.
      #
      # Few things to note:
      #
      # - CI Runner is meant to be installed as a standalone gem, not Bundled (in a Gemfile). CI Runner
      #   doesn't know what's inside the loaded specs of the application and it's possible (while unlikely)
      #   that "Rake" isn't part of the application/gem dependencies. Therefore, when activativing Bundler,
      #   requiring "rake/testtask" would fail inside the Rakefile.
      #
      #   To avoid this problem, requiring rake before Bundler gets activated (using the ruby -rswitch).
      #
      # - The CI Runner Minitest plugin will not be detected once the subprocess starts. (Again because CI Runner
      #   is not part of the application dependencies). Adding it to the LOAD_PATH manually is required.
      def start!
        super

        minitest_plugin_path = File.expand_path("../..", __dir__)
        rake_load_path = Gem.loaded_specs["rake"].full_require_paths.first

        code = <<~EOM
          Rake::TestTask.new(:__ci_runner_test) do |t|
            t.libs << "test"
            t.libs << "lib"
            t.libs << "#{rake_load_path}"
            t.libs << "#{minitest_plugin_path}"
            t.test_files = #{failures.map(&:path)}
          end

          Rake::Task[:__ci_runner_test].invoke
        EOM

        rakefile_path = File.expand_path("Rakefile", Dir.mktmpdir)
        File.write(rakefile_path, code)

        server = DRb.start_service("drbunix:", failures)

        env = { "TESTOPTS" => "--ci-runner=#{server.uri}" }
        env["SEED"] = seed if seed
        env["RUBY"] = ruby_path.to_s if ruby_path&.exist?
        env["BUNDLE_GEMFILE"] = gemfile_path.to_s if gemfile_path&.exist?

        execute_within_frame(env, "bundle exec ruby -r'rake/testtask' #{rakefile_path}")

        DRb.stop_service
      end

      private

      def process_buffer
        super do
          match_data = minitest_failure
          next unless match_data

          file_path = valid_path?(match_data[:file_path]) ? match_data[:file_path] : find_test_location(match_data)

          @failures << TestFailure.new(match_data[:class], match_data[:test_name], file_path)
        end
      end

      # Detect if the buffer contains a Minitest Error/Failure. If not, bail out.
      #
      # @return [nil, MatchData] Whether the regex matched.
      def minitest_failure
        regex = /(?:\s*)(?<class>[a-zA-Z0-9_:]+)\#(?<test_name>test_.+?)(:\s*$|\s+\[(?<file_path>.*):\d+\])/

        regex.match(@buffer)
      end

      # There are two different type of errors in Minitest: Failure and Error.
      # A failure is an assertion that failed `assert(false)`. An error in an unexpected exception `foo.boom`.
      #
      # For failure, Minitest will print the location of the test file, but it can be wrong.
      #
      # MaintenanceTasks::RunsTest#test_run_a_CSV_Task [/home/runner/work/maintenance_tasks/maintenance_tasks/vendor/bundle/ruby/2.7.0/gems/capybara-3.37.1/lib/capybara/minitest.rb:295] # rubocop:disable Layout/LineLength
      #
      # In this case the location of the file points to a file inside a gem, which is for sure not where the test lives.
      # When this happen, we discard the location provided by Minitest and try to match another possible location.
      #
      # @param path [String] A path to a file
      #
      # @return [Boolean] Whether the path points to a gem.
      def valid_path?(path)
        return false if path.nil?

        points_to_a_gem = %r{ruby/.*?/gems}

        !path.match?(points_to_a_gem)
      end

      # Try different alternatives to find where the test file lives.
      #
      # @param match_data [MatchData] The match from the +minitest_failures+
      #
      # @return [String] The path of the test file.
      def find_test_location(match_data)
        match = try_rails
        return match if match

        match = try_infer_file_from_class(match_data)
        return match if match

        match = try_stacktrace(match_data)
        return match if match

        raise("Can't find test location")
      end

      # Taken from ActiveSupport
      #
      # @param camel_cased_word [String]
      #
      # @return [String]
      def underscore(camel_cased_word)
        return camel_cased_word.to_s unless /[A-Z-]|::/.match?(camel_cased_word)

        word = camel_cased_word.to_s.gsub("::", "/")
        word.gsub!(/([A-Z]+)(?=[A-Z][a-z])|([a-z\d])(?=[A-Z])/) do
          (Regexp.last_match(1) || Regexp.last_match(2)) << "_"
        end
        word.tr!("-", "_")
        word.downcase!
        word
      end

      # Try to find the file location using the class name we matched.
      #
      # @param match_data [MatchData] The match from the +minitest_failures+
      #
      # @return [String, nil] The path of the test file. Nil if not found.
      #
      # @example
      #   Given a failure: TestReloading#test_reload_recovers_from_name_errors__w__on_unload_callbacks_:
      #   We try to look for a line from the stacktrace like this one:
      #   /Users/runner/wok/zeitwerk/zeitwerk/test/lib/zeitwerk/test_reloading.rb:12:in `block in <class:TestReloading>'
      def try_stacktrace(match_data)
        regex = %r{\s*(/.*?):\d+:in.*#{match_data[:class]}}

        @buffer.match(regex) { |match| match[1] }
      end

      # Try to find the file location using the class_name -> file convention naming
      #
      # @param match_data [MatchData] The match from the +minitest_failures+
      #
      # @return [String, nil] The path of the test file. Nil if not found.
      #
      # @example
      #   Given a failure: BigProblemTest#test_this_is_problematic
      #
      #   We try to look for a line from the stacktrace like this one:
      #   /Users/runner/work/foo/foo/test/lib/foo/big_problem_test.rb:218
      def try_infer_file_from_class(match_data)
        file_name = underscore(match_data[:class].split("::").last)
        regex = %r{(/.*#{file_name}.*?):\d+}

        @buffer.match(regex) { |match| match[1] }
      end

      # Try to find the file location using the Rails reporter
      #
      # @param match_data [MatchData] The match from the +minitest_failures+
      #
      # @return [String, nil] The path of the test file. Nil if not found.
      def try_rails
        regex = /rails\s+test\s+(.*?):\d+/

        @buffer.match(regex) { |match| match[1] }
      end
    end
  end
end
